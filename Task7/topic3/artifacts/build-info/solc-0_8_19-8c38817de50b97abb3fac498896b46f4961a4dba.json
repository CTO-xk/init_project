{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_19-8c38817de50b97abb3fac498896b46f4961a4dba",
  "solcVersion": "0.8.19",
  "solcLongVersion": "0.8.19+commit.7dd6d404",
  "userSourceNameMap": {
    "src/Arithmetic.sol": "project/src/Arithmetic.sol",
    "src/ArithmeticOptimized.sol": "project/src/ArithmeticOptimized.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "paris",
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/src/Arithmetic.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n/**\n * @title Arithmetic\n * @dev 基本算术运算智能合约\n * @notice 提供加法、减法、乘法、除法等基本运算功能\n */\ncontract Arithmetic {\n    // 存储计算结果\n    uint256 public lastResult;\n    \n    // 存储操作历史\n    struct Operation {\n        uint256 a;\n        uint256 b;\n        string operation;\n        uint256 result;\n        uint256 timestamp;\n    }\n    \n    Operation[] public operations;\n    \n    // 事件声明\n    event CalculationPerformed(\n        uint256 indexed a,\n        uint256 indexed b,\n        string operation,\n        uint256 result,\n        uint256 timestamp\n    );\n    \n    event ErrorOccurred(string message);\n    \n    /**\n     * @dev 执行加法运算\n     * @param a 第一个操作数\n     * @param b 第二个操作数\n     * @return 加法结果\n     */\n    function add(uint256 a, uint256 b) public returns (uint256) {\n        uint256 result = a + b;\n        \n        // 检查溢出\n        require(result >= a, \"Arithmetic: addition overflow\");\n        \n        _updateState(a, b, \"add\", result);\n        return result;\n    }\n    \n    /**\n     * @dev 执行减法运算\n     * @param a 被减数\n     * @param b 减数\n     * @return 减法结果\n     */\n    function subtract(uint256 a, uint256 b) public returns (uint256) {\n        require(b <= a, \"Arithmetic: subtraction underflow\");\n        \n        uint256 result = a - b;\n        _updateState(a, b, \"subtract\", result);\n        return result;\n    }\n    \n    /**\n     * @dev 执行乘法运算\n     * @param a 第一个操作数\n     * @param b 第二个操作数\n     * @return 乘法结果\n     */\n    function multiply(uint256 a, uint256 b) public returns (uint256) {\n        if (a == 0 || b == 0) {\n            _updateState(a, b, \"multiply\", 0);\n            return 0;\n        }\n        \n        uint256 result = a * b;\n        require(result / a == b, \"Arithmetic: multiplication overflow\");\n        \n        _updateState(a, b, \"multiply\", result);\n        return result;\n    }\n    \n    /**\n     * @dev 执行除法运算\n     * @param a 被除数\n     * @param b 除数\n     * @return 除法结果\n     */\n    function divide(uint256 a, uint256 b) public returns (uint256) {\n        require(b > 0, \"Arithmetic: division by zero\");\n        \n        uint256 result = a / b;\n        _updateState(a, b, \"divide\", result);\n        return result;\n    }\n    \n    /**\n     * @dev 执行模运算\n     * @param a 被除数\n     * @param b 除数\n     * @return 模运算结果\n     */\n    function modulo(uint256 a, uint256 b) public returns (uint256) {\n        require(b > 0, \"Arithmetic: modulo by zero\");\n        \n        uint256 result = a % b;\n        _updateState(a, b, \"modulo\", result);\n        return result;\n    }\n    \n    /**\n     * @dev 获取操作历史数量\n     * @return 操作历史总数\n     */\n    function getOperationsCount() public view returns (uint256) {\n        return operations.length;\n    }\n    \n    /**\n     * @dev 获取指定索引的操作历史\n     * @param index 索引\n     * @return a 第一个操作数\n     * @return b 第二个操作数\n     * @return operation 操作类型\n     * @return result 计算结果\n     * @return timestamp 时间戳\n     */\n    function getOperation(uint256 index) public view returns (\n        uint256 a,\n        uint256 b,\n        string memory operation,\n        uint256 result,\n        uint256 timestamp\n    ) {\n        require(index < operations.length, \"Arithmetic: index out of bounds\");\n        \n        Operation memory op = operations[index];\n        return (op.a, op.b, op.operation, op.result, op.timestamp);\n    }\n    \n    /**\n     * @dev 清除操作历史\n     */\n    function clearHistory() public {\n        delete operations;\n        lastResult = 0;\n    }\n    \n    /**\n     * @dev 内部函数：更新合约状态\n     * @param a 第一个操作数\n     * @param b 第二个操作数\n     * @param operation 操作类型\n     * @param result 计算结果\n     */\n    function _updateState(\n        uint256 a,\n        uint256 b,\n        string memory operation,\n        uint256 result\n    ) internal {\n        lastResult = result;\n        \n        operations.push(Operation({\n            a: a,\n            b: b,\n            operation: operation,\n            result: result,\n            timestamp: block.timestamp\n        }));\n        \n        emit CalculationPerformed(a, b, operation, result, block.timestamp);\n    }\n}\n"
      },
      "project/src/ArithmeticOptimized.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n/**\n * @title ArithmeticOptimized\n * @dev 优化后的基本算术运算智能合约\n * @notice 应用多种 Gas 优化策略，减少 Gas 消耗\n */\ncontract ArithmeticOptimized {\n    // 使用 uint128 减少存储成本\n    uint128 public lastResult;\n    \n    // 优化：使用紧凑的结构体减少存储槽位\n    struct Operation {\n        uint128 a;\n        uint128 b;\n        uint8 operationType; // 使用 uint8 替代 string，节省大量 Gas\n        uint128 result;\n        uint32 timestamp; // 使用 uint32 足够表示时间戳\n    }\n    \n    // 优化：使用 mapping 替代数组，减少遍历成本\n    mapping(uint256 => Operation) public operations;\n    uint256 public operationsCount;\n    \n    // 优化：使用事件索引减少 Gas 消耗\n    event CalculationPerformed(\n        uint128 indexed a,\n        uint128 indexed b,\n        uint8 indexed operationType,\n        uint128 result,\n        uint32 timestamp\n    );\n    \n    // 操作类型常量，避免重复的字符串存储\n    uint8 constant ADD = 1;\n    uint8 constant SUBTRACT = 2;\n    uint8 constant MULTIPLY = 3;\n    uint8 constant DIVIDE = 4;\n    uint8 constant MODULO = 5;\n    \n    /**\n     * @dev 执行加法运算\n     * @param a 第一个操作数\n     * @param b 第二个操作数\n     * @return 加法结果\n     */\n    function add(uint128 a, uint128 b) public returns (uint128) {\n        // 优化：内联溢出检查，减少函数调用\n        uint128 result = a + b;\n        require(result >= a, \"Overflow\");\n        \n        _updateState(a, b, ADD, result);\n        return result;\n    }\n    \n    /**\n     * @dev 执行减法运算\n     * @param a 被减数\n     * @param b 减数\n     * @return 减法结果\n     */\n    function subtract(uint128 a, uint128 b) public returns (uint128) {\n        require(b <= a, \"Underflow\");\n        \n        uint128 result = a - b;\n        _updateState(a, b, SUBTRACT, result);\n        return result;\n    }\n    \n    /**\n     * @dev 执行乘法运算\n     * @param a 第一个操作数\n     * @param b 第二个操作数\n     * @return 乘法结果\n     */\n    function multiply(uint128 a, uint128 b) public returns (uint128) {\n        // 优化：早期返回，避免不必要的计算\n        if (a == 0 || b == 0) {\n            _updateState(a, b, MULTIPLY, 0);\n            return 0;\n        }\n        \n        uint128 result = a * b;\n        require(result / a == b, \"Overflow\");\n        \n        _updateState(a, b, MULTIPLY, result);\n        return result;\n    }\n    \n    /**\n     * @dev 执行除法运算\n     * @param a 被除数\n     * @param b 除数\n     * @return 除法结果\n     */\n    function divide(uint128 a, uint128 b) public returns (uint128) {\n        require(b > 0, \"Div by zero\");\n        \n        uint128 result = a / b;\n        _updateState(a, b, DIVIDE, result);\n        return result;\n    }\n    \n    /**\n     * @dev 执行模运算\n     * @param a 被除数\n     * @param b 除数\n     * @return 模运算结果\n     */\n    function modulo(uint128 a, uint128 b) public returns (uint128) {\n        require(b > 0, \"Mod by zero\");\n        \n        uint128 result = a % b;\n        _updateState(a, b, MODULO, result);\n        return result;\n    }\n    \n    /**\n     * @dev 获取操作历史数量\n     * @return 操作历史总数\n     */\n    function getOperationsCount() public view returns (uint256) {\n        return operationsCount;\n    }\n    \n    /**\n     * @dev 获取指定索引的操作历史\n     * @param index 索引\n     * @return a 第一个操作数\n     * @return b 第二个操作数\n     * @return operationType 操作类型\n     * @return result 计算结果\n     * @return timestamp 时间戳\n     */\n    function getOperation(uint256 index) public view returns (\n        uint128 a,\n        uint128 b,\n        uint8 operationType,\n        uint128 result,\n        uint32 timestamp\n    ) {\n        require(index < operationsCount, \"Out of bounds\");\n        \n        Operation memory op = operations[index];\n        return (op.a, op.b, op.operationType, op.result, op.timestamp);\n    }\n    \n    /**\n     * @dev 清除操作历史\n     */\n    function clearHistory() public {\n        // 优化：只重置计数器，保留映射数据（节省 Gas）\n        operationsCount = 0;\n        lastResult = 0;\n    }\n    \n    /**\n     * @dev 内部函数：更新合约状态（优化版本）\n     * @param a 第一个操作数\n     * @param b 第二个操作数\n     * @param operationType 操作类型\n     * @param result 计算结果\n     */\n    function _updateState(\n        uint128 a,\n        uint128 b,\n        uint8 operationType,\n        uint128 result\n    ) internal {\n        lastResult = result;\n        \n        // 优化：直接存储到映射，避免数组操作\n        operations[operationsCount] = Operation({\n            a: a,\n            b: b,\n            operationType: operationType,\n            result: result,\n            timestamp: uint32(block.timestamp)\n        });\n        \n        operationsCount++;\n        \n        emit CalculationPerformed(a, b, operationType, result, uint32(block.timestamp));\n    }\n    \n    /**\n     * @dev 批量执行多个操作（Gas 优化：减少多次交易）\n     * @param a 第一个操作数数组\n     * @param b 第二个操作数数组\n     * @param operationTypes 操作类型数组\n     * @return results 结果数组\n     */\n    function batchExecute(\n        uint128[] calldata a,\n        uint128[] calldata b,\n        uint8[] calldata operationTypes\n    ) public returns (uint128[] memory results) {\n        require(\n            a.length == b.length && b.length == operationTypes.length,\n            \"Length mismatch\"\n        );\n        \n        results = new uint128[](a.length);\n        \n        for (uint256 i = 0; i < a.length; i++) {\n            if (operationTypes[i] == ADD) {\n                results[i] = add(a[i], b[i]);\n            } else if (operationTypes[i] == SUBTRACT) {\n                results[i] = subtract(a[i], b[i]);\n            } else if (operationTypes[i] == MULTIPLY) {\n                results[i] = multiply(a[i], b[i]);\n            } else if (operationTypes[i] == DIVIDE) {\n                results[i] = divide(a[i], b[i]);\n            } else if (operationTypes[i] == MODULO) {\n                results[i] = modulo(a[i], b[i]);\n            }\n        }\n        \n        return results;\n    }\n}\n"
      }
    }
  }
}